/*
    Hakkapeliitta - A UCI chess engine. Copyright (C) 2013-2015 Mikko Aarnos.

    Hakkapeliitta is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hakkapeliitta is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hakkapeliitta. If not, see <http://www.gnu.org/licenses/>.
*/

/// @file movelist.hpp
/// @author Mikko Aarnos

#ifndef MOVELIST_HPP_
#define MOVELIST_HPP_

#include <cassert>
#include <array>
#include "move.hpp"

/// @brief Holds generated moves and their move ordering scores.
///
/// Maximum amount of moves supported is 256.
/// We don't initialize the array containing moves due to it being too expensive. 
/// Due to this, extra care must be taken not to use uninitialized values.
/// Some static code analyzers complain about that but it is working as intended.
class MoveList
{
public:
    /// @brief Default constructor.
    MoveList() noexcept;

    /// @brief Get the move at a given index.
    /// @param index The index.
    /// @return The move at the index.
    Move getMove(int index) const; 

    /// @brief Get the score at a given index.
    /// @param index The index.
    /// @return The score at the index.
    int16_t getScore(int index) const;

    /// @brief Set the move at a given index.
    /// @param index The index.
    /// @param newMove The new move.
    void setMove(int index, const Move& newMove);

    /// @brief Set the score at a given index.
    /// @param index The index.
    /// @param newScore The new score.
    void setScore(int index, int16_t newScore);

    /// @brief Assignment operator which is faster than the default one generated by the compiler.
    /// @param rhs The right-hand side of the assignent.
    /// @return A reference to the lhs movelist.
    MoveList& operator=(const MoveList& rhs);

    /// @brief A perfect forwarder for adding new moves to the movelist.
    template<class... T>
    void emplace_back(T&&... args);

    /// @brief Clears the movelist.
    void clear() noexcept;

    /// @brief Used for changing the size of the movelist. 
    /// @param newSize The new size.
    void resize(int newSize) noexcept;

    /// @brief Return the current size of the movelist.
    /// @return The size. We use int to avoid unsigned/signed comparison warnings.
    int size() const noexcept;

    /// @brief Used for checking if the movelist contains no moves.
    /// @return True if the movelist is empty, false otherwise.
    bool empty() const noexcept;

private:
    std::array<uint32_t, 256> mMoveBuffer;
    int32_t mNumberOfMoves;
};

inline MoveList::MoveList() noexcept : mNumberOfMoves(0) 
{
};

inline Move MoveList::getMove(int index) const
{
    assert(index >= 0 && index < mNumberOfMoves);
    return static_cast<uint16_t>(mMoveBuffer[index]);
}

inline int16_t MoveList::getScore(int index) const
{
    assert(index >= 0 && index < mNumberOfMoves);
    return static_cast<int16_t>(mMoveBuffer[index] >> 16);
}

inline void MoveList::setMove(int index, const Move& newMove)
{
    assert(index >= 0 && index < mNumberOfMoves);
    mMoveBuffer[index] &= 0xFFFF0000;
    mMoveBuffer[index] |= newMove.getRawMove();
    assert(getMove(index) == newMove);
}

inline void MoveList::setScore(int index, int16_t newScore)
{
    assert(index >= 0 && index < mNumberOfMoves);
    mMoveBuffer[index] &= 0xFFFF;
    mMoveBuffer[index] |= static_cast<uint32_t>(newScore) << 16;
    assert(getScore(index) == newScore);
}

inline MoveList& MoveList::operator=(const MoveList& rhs)
{
    mNumberOfMoves = rhs.mNumberOfMoves;
    for (auto i = 0; i < rhs.size(); ++i)
    {
        mMoveBuffer[i] = rhs.mMoveBuffer[i];
    }
    return *this;
}

template<class... T>
inline void MoveList::emplace_back(T&&... args)
{
    mMoveBuffer[mNumberOfMoves++] = Move(std::forward<T>(args)...).getRawMove();
}

inline void MoveList::clear() noexcept
{ 
    mNumberOfMoves = 0;
};

inline void MoveList::resize(int newSize) noexcept
{ 
    mNumberOfMoves = newSize;
}

inline int MoveList::size() const noexcept
{ 
    return mNumberOfMoves;
}

inline bool MoveList::empty() const noexcept
{ 
    return !mNumberOfMoves;
}

#endif
